package kafka

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/csye7125-su24-team05/webapp-cve-processor/app/helper"
	"github.com/csye7125-su24-team05/webapp-cve-processor/app/queue"
	kafkago "github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl"
	"github.com/segmentio/kafka-go/sasl/plain"
	"github.com/segmentio/kafka-go/sasl/scram"
)

type GoKafka struct {
	writer *kafkago.Writer	
	FailedMessages queue.IQueue[any]
}


func CreateKafkaConnection() *GoKafka {
	fmt.Println("Starting Kafka Producer with multiple brokers")
	kfk_topic := os.Getenv("KAFKA_TOPIC")
	username := os.Getenv("KAFKA_USERNAME")
	password := os.Getenv("KAFKA_PASSWORD")
	mechanismType := os.Getenv("SASL_MECHANISM")
	batchTimeout := helper.GetEnvInt("BATCH_TIMEOUT", 1)
	maxBatchBytes := helper.GetEnvInt("MAX_BATCH_SIZE", 1048576)

	brokersList := getBrokers()

	var mechanism sasl.Mechanism
	var err error
	switch mechanismType {
	case "SCRAM-SHA-256":
		mechanism, err = scram.Mechanism(scram.SHA256, username, password)
	case "SCRAM-SHA-512":
		mechanism, err = scram.Mechanism(scram.SHA512, username, password)
	case "PLAIN":
		mechanism = plain.Mechanism{
			Username: username,
			Password: password,
		}
	default:
		fmt.Println("Unsupported SASL mechanism:", mechanismType)
		panic("Unsupported SASL mechanism")
	}

	if err != nil {
		fmt.Println("Error in creating mechanism")
		panic(err)
	}

	PrintTopics(mechanism)
	
	sharedTransport := &kafkago.Transport{
		SASL: mechanism,
	}

	writer := kafkago.Writer{
		Addr: kafkago.TCP(brokersList...),
		Topic: kfk_topic,
		Balancer: &kafkago.RoundRobin{},
		Transport: sharedTransport,
		AllowAutoTopicCreation: true,
		BatchTimeout: time.Duration(batchTimeout) * time.Millisecond,
		BatchBytes: maxBatchBytes,
	}

	return &GoKafka{
		writer: &writer,
		FailedMessages: queue.NewQueue[any](),
	}
}

func(k *GoKafka) WriteMessage(message any) {
	messageBytes, err := json.Marshal(message)
    if err != nil {
        fmt.Println("Error in converting message to bytes: ", err)
        return
    }

    err = k.writer.WriteMessages(context.Background(), kafkago.Message{
        Value: messageBytes,
    })
    if err != nil {
        fmt.Println("Error in writing message: ", err)
		k.FailedMessages.Enqueue(message)
    }
}

func PrintTopics(mechanism sasl.Mechanism) {
	
	dialer := &kafkago.Dialer{
		DualStack:     true,
		SASLMechanism: mechanism,
	}
	brokerList := getBrokers()
	conn, err := dialer.DialContext(context.Background(), "tcp", brokerList[0])
	if err != nil {
		panic(err.Error())
	}
	defer conn.Close()

	partitions, err := conn.ReadPartitions()
	if err != nil {
		panic(err.Error())
	}

	m := map[string]struct{}{}

	for _, p := range partitions {
		m[p.Topic] = struct{}{}
	}
	fmt.Println("Topics: ")
	for k := range m {
		fmt.Println(k)
	}
}

func getBrokers() []string {
	brokers := os.Getenv("KAFKA_BROKER")
	return strings.Split(brokers, ";")
}