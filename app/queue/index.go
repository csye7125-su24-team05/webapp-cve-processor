package queue

type IQueue[T any] interface {
	Enqueue(item T)
	Dequeue() *T
	Top() *T
	Size() int
}

type Queue[T any] struct {
	Items []T
}

func NewQueue[T any]() IQueue[T] {
	return &Queue[T]{
		Items: []T{},
	}
}

func (q *Queue[T]) Size() int {
	return len(q.Items)
}

func (q *Queue[T]) Top() *T {
	if len(q.Items) == 0 {
		return nil
	}
	return &q.Items[0]
}

// Dequeue implements IQueue.
func (q *Queue[T]) Dequeue() *T {
	if len(q.Items) == 0 {
		return nil
	}

	item := q.Items[0]
	if len(q.Items) == 1 {
		q.Items = []T{}
	} else if len(q.Items) > 1 {
		q.Items = q.Items[1:]
	}
	return &item

}

// Enqueue implements IQueue.
func (q *Queue[T]) Enqueue(item T) {
	q.Items = append(q.Items, item)
}
